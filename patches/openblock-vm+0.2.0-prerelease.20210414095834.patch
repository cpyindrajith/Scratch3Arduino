diff --git a/node_modules/openblock-vm/dist/web/openblock-vm.js b/node_modules/openblock-vm/dist/web/openblock-vm.js
index 400193c..350514e 100644
--- a/node_modules/openblock-vm/dist/web/openblock-vm.js
+++ b/node_modules/openblock-vm/dist/web/openblock-vm.js
@@ -50406,6 +50406,9 @@ function () {
 
       return new Promise(function (resolve) {
         fetch(localDeviceExtensionsUrl).then(function (response) {
+			
+			
+			console.log(response);
           return response.json();
         }).then(function (extensions) {
           extensions = extensions.map(function (extension) {
diff --git a/node_modules/openblock-vm/src/devices/arduinoLeonardo/index.js b/node_modules/openblock-vm/src/devices/arduinoLeonardo/index.js
index 512fda4..61dc3b2 100644
--- a/node_modules/openblock-vm/src/devices/arduinoLeonardo/index.js
+++ b/node_modules/openblock-vm/src/devices/arduinoLeonardo/index.js
@@ -38,6 +38,7 @@ const SERIAL_CONFIG = {
 const DIVECE_OPT = {
     type: 'arduino',
     fqbn: 'arduino:avr:leonardo'
+   
 };
 
 /**
diff --git a/node_modules/openblock-vm/src/devices/arduinoNano/index-Working.js b/node_modules/openblock-vm/src/devices/arduinoNano/index-Working.js
new file mode 100644
index 0000000..3779c0e
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoNano/index-Working.js
@@ -0,0 +1,1432 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const ProgramModeType = require('../../extension-support/program-mode-type');
+const Serialport = require('../../io/serialport');
+const Base64Util = require('../../util/base64-util');
+
+const Firmata = require('../../lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+    // CH340
+    'USB\\VID_1A86&PID_7523'
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    fqbn: 'arduino:avr:nano:cpu=atmega328p',
+    baudrate: '115200'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoUno.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Nano peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoNano{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Nano peripheral.
+ */
+class OpenBlockArduinoNanoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoNano';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino Nano peripheral instance
+        this._peripheral = new ArduinoNano(this.runtime, OpenBlockArduinoNanoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoUno.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino uno device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoUno set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoUno set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoUno set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoUno read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoUno read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoUno set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoUno attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoUno detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoUno.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino uno device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoUno serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoUno serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoUno serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoUno serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoUno.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino uno device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoUno data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoUno data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoUno data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoUno data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoUno data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoNanoDevice;
diff --git a/node_modules/openblock-vm/src/devices/arduinoNano/index.js b/node_modules/openblock-vm/src/devices/arduinoNano/index.js
index 5a7c3c9..ef35d84 100644
--- a/node_modules/openblock-vm/src/devices/arduinoNano/index.js
+++ b/node_modules/openblock-vm/src/devices/arduinoNano/index.js
@@ -32,9 +32,13 @@ const SERIAL_CONFIG = {
  * Configuration of build and flash. Used by arduino_debug and avrdude.
  * @readonly
  */
-const DIVECE_OPT = {
+ const DIVECE_OPT = {
     type: 'arduino',
-    fqbn: 'arduino:avr:nano:cpu=atmega328'
+    // fqbn: 'arduino:avr:nano:cpu=ATmega328old',
+    fqbn: 'arduino:avr:nano:cpu=atmega328old',
+    partno: 'atmega328p (old bootloader)',
+    programmerId: 'arduino',
+    baudrate: '57600'
 };
 
 /**
diff --git a/node_modules/openblock-vm/src/devices/arduinoNano/index.zip b/node_modules/openblock-vm/src/devices/arduinoNano/index.zip
new file mode 100644
index 0000000..6b3e3b9
Binary files /dev/null and b/node_modules/openblock-vm/src/devices/arduinoNano/index.zip differ
diff --git a/node_modules/openblock-vm/src/devices/arduinoNano/index1.js b/node_modules/openblock-vm/src/devices/arduinoNano/index1.js
new file mode 100644
index 0000000..bc9d5a3
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoNano/index1.js
@@ -0,0 +1,1444 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const ProgramModeType = require('../../extension-support/program-mode-type');
+const Serialport = require('../../io/serialport');
+const Base64Util = require('../../util/base64-util');
+
+const Firmata = require('../../lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+
+     // https://github.com/arduino/Arduino/blob/1.8.0/hardware/arduino/avr/boards.txt#L51-L58
+    'USB\\VID_2341&PID_0043',
+    'USB\\VID_2341&PID_0001',
+    'USB\\VID_2A03&PID_0043',
+    'USB\\VID_2341&PID_0243',
+    // For chinese clones that use CH340
+    'USB\\VID_1A86&PID_7523',
+    // FT232
+    'USB\\VID_0403&PID_6001',
+    // CP2102
+    'USB\\VID_10C4&PID_EA60'
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    fqbn: 'arduino:avr:nano:cpu=atmega328p',
+    partno: 'ATmega328P',
+    programmerId: 'arduino',
+    baudrate: '115200'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoNano.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Nano peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoNano{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Nano peripheral.
+ */
+class OpenBlockArduinoNanoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoNano';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino Nano peripheral instance
+        this._peripheral = new ArduinoNano(this.runtime, OpenBlockArduinoNanoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoNano.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino Nano device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoNano set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoNano set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoNano set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoNano read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoNano read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoNano set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoNano attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoNano detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoNano.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino Nano device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoNano.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoNano serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoNano.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoNano serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoNano.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoNano serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoNano.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoNano serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoNano.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino Nano device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoNano data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoNano data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoNano data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoNano data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoNano data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoNanoDevice;
diff --git a/node_modules/openblock-vm/src/devices/arduinoNano/index_w.js b/node_modules/openblock-vm/src/devices/arduinoNano/index_w.js
new file mode 100644
index 0000000..547b478
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoNano/index_w.js
@@ -0,0 +1,1449 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const ProgramModeType = require('../../extension-support/program-mode-type');
+const Serialport = require('../../io/serialport');
+const Base64Util = require('../../util/base64-util');
+
+const Firmata = require('../../lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+    // https://github.com/arduino/Arduino/blob/1.8.0/hardware/arduino/avr/boards.txt#L51-L58
+    'USB\\VID_2341&PID_0043',
+    'USB\\VID_2341&PID_0001',
+    'USB\\VID_2A03&PID_0043',
+    'USB\\VID_2341&PID_0243',
+    // For chinese clones that use CH340
+    'USB\\VID_1A86&PID_7523',
+    // FT232
+    'USB\\VID_0403&PID_6001',
+    // CP2102
+    'USB\\VID_10C4&PID_EA60',
+    // PL2303
+    'USB\\VID_067B&PID_2303',
+    'USB\\VID_0403&PID_6001'
+
+
+
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    fqbn: 'arduino:avr:nano:cpu=atmega328old',
+    partno: 'ATmega328P',
+    programmerId: 'arduino',
+    baudrate: '115200'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoNano.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Uno peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoUno{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Uno peripheral.
+ */
+class OpenBlockArduinoUnoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoUno';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino uno peripheral instance
+        this._peripheral = new ArduinoUno(this.runtime, OpenBlockArduinoUnoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoUno.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino uno device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoUno set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoUno set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoUno set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoUno read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoUno read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoUno set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoUno attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoUno detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoUno.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino uno device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoUno serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoUno serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoUno serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoUno serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoUno.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino uno device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoUno data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoUno data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoUno data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoUno data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoUno data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoUnoDevice;
diff --git a/node_modules/openblock-vm/src/devices/arduinoNanoOld/index-Working.js b/node_modules/openblock-vm/src/devices/arduinoNanoOld/index-Working.js
new file mode 100644
index 0000000..3779c0e
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoNanoOld/index-Working.js
@@ -0,0 +1,1432 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const ProgramModeType = require('../../extension-support/program-mode-type');
+const Serialport = require('../../io/serialport');
+const Base64Util = require('../../util/base64-util');
+
+const Firmata = require('../../lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+    // CH340
+    'USB\\VID_1A86&PID_7523'
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    fqbn: 'arduino:avr:nano:cpu=atmega328p',
+    baudrate: '115200'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoUno.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Nano peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoNano{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Nano peripheral.
+ */
+class OpenBlockArduinoNanoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoNano';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino Nano peripheral instance
+        this._peripheral = new ArduinoNano(this.runtime, OpenBlockArduinoNanoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoUno.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino uno device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoUno set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoUno set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoUno set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoUno read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoUno read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoUno set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoUno attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoUno detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoUno.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino uno device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoUno serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoUno serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoUno serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoUno serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoUno.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino uno device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoUno data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoUno data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoUno data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoUno data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoUno data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoNanoDevice;
diff --git a/node_modules/openblock-vm/src/devices/arduinoNanoOld/index.js b/node_modules/openblock-vm/src/devices/arduinoNanoOld/index.js
new file mode 100644
index 0000000..b041d32
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoNanoOld/index.js
@@ -0,0 +1,1435 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const ProgramModeType = require('../../extension-support/program-mode-type');
+const Serialport = require('../../io/serialport');
+const Base64Util = require('../../util/base64-util');
+
+const Firmata = require('../../lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+    // CH340
+    'USB\\VID_1A86&PID_7523'
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    // fqbn: 'arduino:avr:nano:cpu=ATmega328old',
+    fqbn: 'arduino:avr:nano:cpu=atmega328old',
+    partno: 'atmega328p (old bootloader)',
+    programmerId: 'arduino',
+    baudrate: '57600'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoNanoOld.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Nano peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoNano{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Nano peripheral.
+ */
+class OpenBlockArduinoNanoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoNano';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNanoOld.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino Nano peripheral instance
+        this._peripheral = new ArduinoNano(this.runtime, OpenBlockArduinoNanoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoNanoOld.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino uno device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoNanoOld set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoNanoOld set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoNanoOld set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoNanoOld read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoNanoOld read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoNanoOld set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoNanoOld attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoNanoOld detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoNanoOld.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino uno device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoNanoOld serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoNanoOld serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoNanoOld serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoNanoOld serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoNanoOld.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino uno device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoNanoOld data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoNanoOld data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoNanoOld data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoNanoOld data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoNanoOld.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoNanoOld data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoNanoDevice;
diff --git a/node_modules/openblock-vm/src/devices/arduinoNanoOld/index1.js b/node_modules/openblock-vm/src/devices/arduinoNanoOld/index1.js
new file mode 100644
index 0000000..bc9d5a3
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoNanoOld/index1.js
@@ -0,0 +1,1444 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const ProgramModeType = require('../../extension-support/program-mode-type');
+const Serialport = require('../../io/serialport');
+const Base64Util = require('../../util/base64-util');
+
+const Firmata = require('../../lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+
+     // https://github.com/arduino/Arduino/blob/1.8.0/hardware/arduino/avr/boards.txt#L51-L58
+    'USB\\VID_2341&PID_0043',
+    'USB\\VID_2341&PID_0001',
+    'USB\\VID_2A03&PID_0043',
+    'USB\\VID_2341&PID_0243',
+    // For chinese clones that use CH340
+    'USB\\VID_1A86&PID_7523',
+    // FT232
+    'USB\\VID_0403&PID_6001',
+    // CP2102
+    'USB\\VID_10C4&PID_EA60'
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    fqbn: 'arduino:avr:nano:cpu=atmega328p',
+    partno: 'ATmega328P',
+    programmerId: 'arduino',
+    baudrate: '115200'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoNano.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Nano peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoNano{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Nano peripheral.
+ */
+class OpenBlockArduinoNanoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoNano';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoNano.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino Nano peripheral instance
+        this._peripheral = new ArduinoNano(this.runtime, OpenBlockArduinoNanoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoNano.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino Nano device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoNano set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoNano set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoNano set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoNano read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoNano read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoNano set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoNano attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoNano.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoNano detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoNano.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino Nano device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoNano.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoNano serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoNano.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoNano serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoNano.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoNano serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoNano.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoNano serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoNano.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino Nano device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoNano data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoNano data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoNano data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoNano data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoNano.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoNano data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoNanoDevice;
diff --git a/node_modules/openblock-vm/src/devices/arduinoNanoOld/indexFinalWorking.js b/node_modules/openblock-vm/src/devices/arduinoNanoOld/indexFinalWorking.js
new file mode 100644
index 0000000..5c28fc0
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoNanoOld/indexFinalWorking.js
@@ -0,0 +1,1434 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const ProgramModeType = require('../../extension-support/program-mode-type');
+const Serialport = require('../../io/serialport');
+const Base64Util = require('../../util/base64-util');
+
+const Firmata = require('../../lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+    // CH340
+    'USB\\VID_1A86&PID_7523'
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    fqbn: 'arduino:avr:nano',
+    partno: 'ATmega328P',
+    programmerId: 'arduino',
+    baudrate: '115200'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoUno.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Nano peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoNano{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Nano peripheral.
+ */
+class OpenBlockArduinoNanoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoNano';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino Nano peripheral instance
+        this._peripheral = new ArduinoNano(this.runtime, OpenBlockArduinoNanoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoUno.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino uno device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoUno set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoUno set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoUno set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoUno read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoUno read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoUno set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoUno attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoUno detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoUno.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino uno device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoUno serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoUno serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoUno serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoUno serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoUno.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino uno device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoUno data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoUno data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoUno data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoUno data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoUno data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoNanoDevice;
diff --git a/node_modules/openblock-vm/src/devices/arduinoNanoOld/index_w.js b/node_modules/openblock-vm/src/devices/arduinoNanoOld/index_w.js
new file mode 100644
index 0000000..547b478
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoNanoOld/index_w.js
@@ -0,0 +1,1449 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('../../extension-support/argument-type');
+const BlockType = require('../../extension-support/block-type');
+const ProgramModeType = require('../../extension-support/program-mode-type');
+const Serialport = require('../../io/serialport');
+const Base64Util = require('../../util/base64-util');
+
+const Firmata = require('../../lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+    // https://github.com/arduino/Arduino/blob/1.8.0/hardware/arduino/avr/boards.txt#L51-L58
+    'USB\\VID_2341&PID_0043',
+    'USB\\VID_2341&PID_0001',
+    'USB\\VID_2A03&PID_0043',
+    'USB\\VID_2341&PID_0243',
+    // For chinese clones that use CH340
+    'USB\\VID_1A86&PID_7523',
+    // FT232
+    'USB\\VID_0403&PID_6001',
+    // CP2102
+    'USB\\VID_10C4&PID_EA60',
+    // PL2303
+    'USB\\VID_067B&PID_2303',
+    'USB\\VID_0403&PID_6001'
+
+
+
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    fqbn: 'arduino:avr:nano:cpu=atmega328old',
+    partno: 'ATmega328P',
+    programmerId: 'arduino',
+    baudrate: '115200'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoNano.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Uno peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoUno{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Uno peripheral.
+ */
+class OpenBlockArduinoUnoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoUno';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUno.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino uno peripheral instance
+        this._peripheral = new ArduinoUno(this.runtime, OpenBlockArduinoUnoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoUno.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino uno device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoUno set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoUno set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoUno set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoUno read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoUno read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoUno set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoUno attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUno.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoUno detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoUno.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino uno device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoUno serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoUno serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoUno serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoUno.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoUno serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoUno.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino uno device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoUno data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoUno data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoUno data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoUno data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoUno.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoUno data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoUnoDevice;
diff --git a/node_modules/openblock-vm/src/devices/arduinoUno/index.js b/node_modules/openblock-vm/src/devices/arduinoUno/index.js
index 90c938e..fc87e83 100644
--- a/node_modules/openblock-vm/src/devices/arduinoUno/index.js
+++ b/node_modules/openblock-vm/src/devices/arduinoUno/index.js
@@ -20,7 +20,11 @@ const PNPID_LIST = [
     'USB\\VID_2A03&PID_0043',
     'USB\\VID_2341&PID_0243',
     // For chinese clones that use CH340
-    'USB\\VID_1A86&PID_7523'
+    'USB\\VID_1A86&PID_7523',
+    // FT232
+    'USB\\VID_0403&PID_6001',
+    // CP2102
+    'USB\\VID_10C4&PID_EA60'
 ];
 
 /**
@@ -39,7 +43,10 @@ const SERIAL_CONFIG = {
  */
 const DIVECE_OPT = {
     type: 'arduino',
-    fqbn: 'arduino:avr:uno'
+    fqbn: 'arduino:avr:uno',
+    partno: 'ATmega328P',
+    programmerId: 'arduino',
+    baudrate: '115200'
 };
 
 /**
diff --git a/node_modules/openblock-vm/src/devices/arduinoUnoOld/index.js b/node_modules/openblock-vm/src/devices/arduinoUnoOld/index.js
new file mode 100644
index 0000000..887f1f5
--- /dev/null
+++ b/node_modules/openblock-vm/src/devices/arduinoUnoOld/index.js
@@ -0,0 +1,1443 @@
+const formatMessage = require('format-message');
+const Buffer = require('buffer').Buffer;
+
+const ArgumentType = require('openblock-vm/src/extension-support/argument-type');
+const BlockType = require('openblock-vm/src/extension-support/block-type');
+const ProgramModeType = require('openblock-vm/src/extension-support/program-mode-type');
+const Serialport = require('openblock-vm/src/io/serialport');
+const Base64Util = require('openblock-vm/src/util/base64-util');
+
+const Firmata = require('openblock-vm/src/lib/firmata/firmata');
+
+/**
+ * The list of USB device filters.
+ * @readonly
+ */
+const PNPID_LIST = [
+    // https://github.com/arduino/Arduino/blob/1.8.0/hardware/arduino/avr/boards.txt#L51-L58
+    'USB\\VID_2341&PID_0043',
+    'USB\\VID_2341&PID_0001',
+    'USB\\VID_2A03&PID_0043',
+    'USB\\VID_2341&PID_0243',
+    // For chinese clones that use CH340
+    'USB\\VID_1A86&PID_7523',
+    // FT232
+    'USB\\VID_0403&PID_6001',
+    // CP2102
+    'USB\\VID_10C4&PID_EA60'
+];
+
+/**
+ * Configuration of serialport
+ * @readonly
+ */
+const SERIAL_CONFIG = {
+    baudRate: 57600,
+    dataBits: 8,
+    stopBits: 1
+};
+
+/**
+ * Configuration of build and flash. Used by arduino_debug and avrdude.
+ * @readonly
+ */
+const DIVECE_OPT = {
+    type: 'arduino',
+    fqbn: 'arduino:avr:uno',
+    partno: 'ATmega328P',
+    programmerId: 'arduino',
+    baudrate: '115200'
+};
+
+/**
+ * A string to report connect firmata timeout.
+ * @type {formatMessage}
+ */
+const ConnectFirmataTimeout = formatMessage({
+    id: 'arduinoUnoOld.connection.connectFirmataTimeout',
+    default: 'Timeout when try to connect firmata, please download the firmware first',
+    description: 'label for connect firmata timeout'
+});
+
+/**
+ * A time interval to send firmata heartbeat(in milliseconds).
+ */
+const FrimataHeartbeatInterval = 2000;
+
+/**
+ * A time interval to wait (in milliseconds) before reporting to the serialport socket
+ * that heartbeat has stopped coming from the peripheral.
+ */
+const FrimataHeartbeatTimeout = 5000;
+
+const Pins = {
+    D0: '0',
+    D1: '1',
+    D2: '2',
+    D3: '3',
+    D4: '4',
+    D5: '5',
+    D6: '6',
+    D7: '7',
+    D8: '8',
+    D9: '9',
+    D10: '10',
+    D11: '11',
+    D12: '12',
+    D13: '13',
+    A0: 'A0',
+    A1: 'A1',
+    A2: 'A2',
+    A3: 'A3',
+    A4: 'A4',
+    A5: 'A5'
+};
+
+
+const Level = {
+    High: 'HIGH',
+    Low: 'LOW'
+};
+
+const Buadrate = {
+    B4800: '4800',
+    B9600: '9600',
+    B19200: '19200',
+    B38400: '38400',
+    B57600: '57600',
+    B115200: '115200'
+};
+
+const Eol = {
+    Warp: 'warp',
+    NoWarp: 'noWarp'
+};
+
+const Mode = {
+    Input: 'INPUT',
+    Output: 'OUTPUT',
+    InputPullup: 'INPUT_PULLUP'
+};
+
+const InterrupMode = {
+    Rising: 'RISING',
+    Falling: 'FALLING',
+    Change: 'CHANGE',
+    Low: 'LOW'
+};
+
+const DataType = {
+    WholeNumber: 'WHOLE_NUMBER',
+    Decimal: 'DECIMAL',
+    String: 'STRING'
+};
+
+/**
+ * Manage communication with a Arduino Uno peripheral over a OpenBlock Link client socket.
+ */
+class ArduinoUno{
+
+    /**
+     * Construct a Arduino communication object.
+     * @param {Runtime} runtime - the OpenBlock runtime
+     * @param {string} deviceId - the id of the extension
+     */
+    constructor (runtime, deviceId) {
+        /**
+         * The OpenBlock runtime used to trigger the green flag button.
+         * @type {Runtime}
+         * @private
+         */
+        this._runtime = runtime;
+
+        /**
+         * The serialport connection socket for reading/writing peripheral data.
+         * @type {SERIALPORT}
+         * @private
+         */
+        this._serialport = null;
+        this._runtime.registerPeripheralExtension(deviceId, this);
+        this._runtime.setRealtimeBaudrate(SERIAL_CONFIG.baudRate);
+
+        /**
+         * The id of the extension this peripheral belongs to.
+         */
+        this._deviceId = deviceId;
+
+        /**
+        * Pending data list. If busy is set when send, the data will push into this array to
+        * waitting to be sended.
+        */
+        this._pendingData = [];
+
+        this.reset = this.reset.bind(this);
+        this._onConnect = this._onConnect.bind(this);
+        this._onMessage = this._onMessage.bind(this);
+
+        /**
+         * Firmata connection.
+         * @type {?Firmata}
+         * @private
+         */
+        this._firmata = null;
+
+        /**
+         * Timeout ID for firmata get heartbeat timeout.
+         * @type {number}
+         * @private
+         */
+        this._firmataTimeoutID = null;
+
+        /**
+         * Interval ID for firmata send heartbeat.
+         * @type {number}
+         * @private
+         */
+        this._firmataIntervelID = null;
+
+        /**
+         * A flag that is true while firmata is conncted.
+         * @type {boolean}
+         * @private
+         */
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Called by the runtime when user wants to upload code to a peripheral.
+     * @param {string} code - the code want to upload.
+     */
+    upload (code) {
+        const base64Str = Buffer.from(code).toString('base64');
+        this._serialport.upload(base64Str, DIVECE_OPT, 'base64');
+    }
+
+    /**
+     * Called by the runtime when user wants to upload realtime firmware to a peripheral.
+     */
+    uploadFirmware () {
+        this.stopHeartbeat();
+        this._serialport.uploadFirmware(DIVECE_OPT);
+    }
+
+    /**
+     * Called by the runtime when user wants to scan for a peripheral.
+     * @param {Array.<string>} pnpidList - the array of pnp id list
+     */
+    scan (pnpidList) {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+        this._serialport = new Serialport(this._runtime, this._deviceId, {
+            filters: {
+                pnpid: pnpidList ? pnpidList : PNPID_LIST
+            }
+        }, this._onConnect, this.reset);
+    }
+
+    /**
+     * Called by the runtime when user wants to connect to a certain peripheral.
+     * @param {number} id - the id of the peripheral to connect to.
+     * @param {?number} baudrate - the baudrate.
+     */
+    connect (id, baudrate = null) {
+        const config = SERIAL_CONFIG;
+        if (baudrate) {
+            config.baudRate = baudrate;
+        }
+        if (this._serialport) {
+            this._serialport.connectPeripheral(id, {config: config});
+        }
+    }
+
+    /**
+     * Disconnect from the peripheral.
+     */
+    disconnect () {
+        if (this._serialport) {
+            this._serialport.disconnect();
+        }
+
+        this.reset();
+    }
+
+    /**
+     * Reset all the state and timeout/interval ids.
+     */
+    reset () {
+        if (this._firmata) {
+            this._firmata.removeListener('reportversion', this.listenHeartbeat.bind(this));
+            delete this._firmata;
+        }
+        if (this._firmataTimeoutID) {
+            window.clearTimeout(this._firmataTimeoutID);
+            this._firmataTimeoutID = null;
+        }
+        if (this._firmataIntervelID) {
+            window.clearInterval(this._firmataIntervelID);
+            this._firmataIntervelID = null;
+        }
+        this._isFirmataConnected = false;
+    }
+
+    /**
+     * Return true if connected to the peripheral.
+     * @return {boolean} - whether the peripheral is connected.
+     */
+    isConnected () {
+        let connected = false;
+        if (this._serialport) {
+            connected = this._serialport.isConnected();
+        }
+        return connected;
+    }
+
+    /**
+     * Set baudrate of the peripheral serialport.
+     * @param {number} baudrate - the baudrate.
+     */
+    setBaudrate (baudrate) {
+        this._serialport.setBaudrate(baudrate);
+    }
+
+    /**
+     * Write data to the peripheral serialport.
+     * @param {string} data - the data to write.
+     */
+    write (data) {
+        if (!this.isConnected()) return;
+
+        const base64Str = data.toString('base64');
+        this._serialport.write(base64Str, 'base64');
+    }
+
+    /**
+     * Send a message to the peripheral Serialport socket.
+     * @param {Uint8Array} message - the message to write
+     */
+    send (message) {
+        if (!this.isConnected()) return;
+
+        const data = Base64Util.uint8ArrayToBase64(message);
+        this._serialport.write(data, 'base64');
+    }
+
+    /**
+     * Start send/recive heartbeat timer.
+     * @private
+     */
+    startHeartbeat () {
+        this._isFirmataConnected = false;
+
+        this._firmataIntervelID = window.setInterval(() => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                // Send reportVersion request as heartbeat.
+                this._firmata.reportVersion(() => { });
+            }
+        }, FrimataHeartbeatInterval);
+        // Start a timer if heartbeat time out means failed to connect firmata.
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Stop send/recive heartbeat timer.
+     * @private
+     */
+    stopHeartbeat () {
+        window.clearInterval(this._firmataIntervelID);
+        this._firmataIntervelID = null;
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = null;
+    }
+
+    /**
+     * Listen the heartbeat and emit connection state event.
+     * @private
+     */
+    listenHeartbeat () {
+        if (!this._isFirmataConnected) {
+            this._isFirmataConnected = true;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeConnectSucess();
+            }
+        }
+        // Reset the timeout timer
+        window.clearTimeout(this._firmataTimeoutID);
+        this._firmataTimeoutID = window.setTimeout(() => {
+            this._isFirmataConnected = false;
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this._serialport.handleRealtimeDisconnectError(ConnectFirmataTimeout);
+            }
+        }, FrimataHeartbeatTimeout);
+    }
+
+    /**
+     * Starts reading data from peripheral after serialport has connected to it.
+     * @private
+     */
+    _onConnect () {
+        this._serialport.read(this._onMessage);
+        this._firmata = new Firmata(this.send.bind(this));
+
+        if (this._runtime.getCurrentIsRealtimeMode()) {
+            this.startHeartbeat();
+        }
+
+        this._runtime.on(this._runtime.constructor.PROGRAM_MODE_UPDATE, data => {
+            if (data.isRealtimeMode) {
+                this.startHeartbeat();
+            } else {
+                this.stopHeartbeat();
+            }
+        });
+        this._runtime.on(this._runtime.constructor.PERIPHERAL_UPLOAD_SUCCESS, () => {
+            if (this._runtime.getCurrentIsRealtimeMode()) {
+                this.startHeartbeat();
+            }
+        });
+        // Start the heartbeat listener.
+        this._firmata.on('reportversion', this.listenHeartbeat.bind(this));
+    }
+
+    /**
+     * Process the sensor data from the incoming serialport characteristic.
+     * @param {object} base64 - the incoming serialport data.
+     * @private
+     */
+    _onMessage (base64) {
+        // parse data
+        const data = Base64Util.base64ToUint8Array(base64);
+        this._firmata.onReciveData(data);
+    }
+
+    /**
+     * Return true if peripheral has connected to firmata and program mode is realtime.
+     * @return {boolean} - whether the peripheral is ready for realtime mode communication.
+     */
+    isReady () {
+        if (this._runtime.getCurrentIsRealtimeMode() && this._isFirmataConnected) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param {PIN} pin - the pin string to parse.
+     * @return {number} - the pin number.
+     */
+    parsePin (pin) {
+        if (pin.charAt(0) === 'A') {
+            return parseInt(pin.slice(1), 10) + 14;
+        }
+        return parseInt(pin, 10);
+    }
+
+    /**
+     * @param {LEVEL} level - the level string to parse.
+     * @return {number} - the level in number.
+     */
+    parseLevel (level) {
+        if (level === Level.High) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {MODE} mode - the pin mode to set.
+     */
+    setPinMode (pin, mode) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            switch (mode) {
+            case Mode.Input:
+                mode = this._firmata.MODES.INPUT;
+                break;
+            case Mode.Output:
+                mode = this._firmata.MODES.OUTPUT;
+                break;
+            case Mode.InputPullup:
+                mode = this._firmata.MODES.PULLUP;
+                break;
+            }
+            this._firmata.pinMode(pin, mode);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {LEVEL} level - the pin level to set.
+     */
+    setDigitalOutput (pin, level) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            level = this.parseLevel(level);
+            this._firmata.digitalWrite(pin, level);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the pwm value to set.
+     */
+    setPwmOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 255) {
+                value = 255;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readDigitalPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            return new Promise(resolve => {
+                this._firmata.digitalRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to read.
+     * @return {Promise} - a Promise that resolves when read from peripheral.
+     */
+    readAnalogPin (pin) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            // Shifting to analog pin number.
+            pin = pin - 14;
+            this._firmata.pinMode(pin, this._firmata.MODES.ANALOG);
+            return new Promise(resolve => {
+                this._firmata.analogRead(pin, value => {
+                    resolve(value);
+                });
+            });
+        }
+    }
+
+    /**
+     * @param {PIN} pin - the pin to set.
+     * @param {VALUE} value - the degree to set.
+     */
+    setServoOutput (pin, value) {
+        if (this.isReady()) {
+            pin = this.parsePin(pin);
+            if (value < 0) {
+                value = 0;
+            }
+            if (value > 180) {
+                value = 180;
+            }
+            this._firmata.pinMode(pin, this._firmata.MODES.PWM);
+            this._firmata.pwmWrite(pin, value);
+
+            this._firmata.servoConfig(pin, 600, 2400);
+            this._firmata.servoWrite(pin, value);
+        }
+    }
+}
+
+/**
+ * OpenBlock blocks to interact with a Arduino Uno peripheral.
+ */
+class OpenBlockArduinoUnoDevice {
+    /**
+     * @return {string} - the ID of this extension.
+     */
+    static get DEVICE_ID () {
+        return 'arduinoUnoOld';
+    }
+
+    get PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            },
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.modeMenu.input',
+                    default: 'Input',
+                    description: 'label for input pin mode'
+                }),
+                value: Mode.Input
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.modeMenu.output',
+                    default: 'Output',
+                    description: 'label for output pin mode'
+                }),
+                value: Mode.Output
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.modeMenu.inputPullup',
+                    default: 'Input-pullup',
+                    description: 'label for input-pullup pin mode'
+                }),
+                value: Mode.InputPullup
+            }
+        ];
+    }
+
+    get DIGITAL_PINS_MENU () {
+        return [
+            {
+                text: '0',
+                value: Pins.D0
+            },
+            {
+                text: '1',
+                value: Pins.D1
+            },
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '4',
+                value: Pins.D4
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '7',
+                value: Pins.D7
+            },
+            {
+                text: '8',
+                value: Pins.D8
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            },
+            {
+                text: '12',
+                value: Pins.D12
+            },
+            {
+                text: '13',
+                value: Pins.D13
+            }
+        ];
+    }
+
+    get ANALOG_PINS_MENU () {
+        return [
+            {
+                text: 'A0',
+                value: Pins.A0
+            },
+            {
+                text: 'A1',
+                value: Pins.A1
+            },
+            {
+                text: 'A2',
+                value: Pins.A2
+            },
+            {
+                text: 'A3',
+                value: Pins.A3
+            },
+            {
+                text: 'A4',
+                value: Pins.A4
+            },
+            {
+                text: 'A5',
+                value: Pins.A5
+            }
+        ];
+    }
+
+    get LEVEL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.levelMenu.high',
+                    default: 'High',
+                    description: 'label for high level'
+                }),
+                value: Level.High
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.levelMenu.low',
+                    default: 'Low',
+                    description: 'label for low level'
+                }),
+                value: Level.Low
+            }
+        ];
+    }
+
+    get PWM_PINS_MENU () {
+        return [
+            {
+                text: '3',
+                value: Pins.D3
+            },
+            {
+                text: '5',
+                value: Pins.D5
+            },
+            {
+                text: '6',
+                value: Pins.D6
+            },
+            {
+                text: '9',
+                value: Pins.D9
+            },
+            {
+                text: '10',
+                value: Pins.D10
+            },
+            {
+                text: '11',
+                value: Pins.D11
+            }
+        ];
+    }
+
+    get INTERRUPT_PINS_MENU () {
+        return [
+            {
+                text: '2',
+                value: Pins.D2
+            },
+            {
+                text: '3',
+                value: Pins.D3
+            }
+        ];
+    }
+
+    get INTERRUP_MODE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.InterrupModeMenu.risingEdge',
+                    default: 'rising edge',
+                    description: 'label for rising edge interrup'
+                }),
+                value: InterrupMode.Rising
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.InterrupModeMenu.fallingEdge',
+                    default: 'falling edge',
+                    description: 'label for falling edge interrup'
+                }),
+                value: InterrupMode.Falling
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.InterrupModeMenu.changeEdge',
+                    default: 'change edge',
+                    description: 'label for change edge interrup'
+                }),
+                value: InterrupMode.Change
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.InterrupModeMenu.low',
+                    default: 'low',
+                    description: 'label for low interrup'
+                }),
+                value: InterrupMode.Low
+            }
+        ];
+    }
+
+    get BAUDTATE_MENU () {
+        return [
+            {
+                text: '4800',
+                value: Buadrate.B4800
+            },
+            {
+                text: '9600',
+                value: Buadrate.B9600
+            },
+            {
+                text: '19200',
+                value: Buadrate.B19200
+            },
+            {
+                text: '38400',
+                value: Buadrate.B38400
+            },
+            {
+                text: '57600',
+                value: Buadrate.B57600
+            },
+            {
+                text: '115200',
+                value: Buadrate.B115200
+            }
+        ];
+    }
+
+    get EOL_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.eolMenu.warp',
+                    default: 'Warp',
+                    description: 'label for warp print'
+                }),
+                value: Eol.Warp
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.eolMenu.noWarp',
+                    default: 'No warp',
+                    description: 'label for no warp print'
+                }),
+                value: Eol.NoWarp
+            }
+        ];
+    }
+
+    get DATA_TYPE_MENU () {
+        return [
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.dataTypeMenu.wholeNumber',
+                    default: 'whole number',
+                    description: 'label for whole number'
+                }),
+                value: DataType.WholeNumber
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.dataTypeMenu.decimal',
+                    default: 'decimal',
+                    description: 'label for decimal number'
+                }),
+                value: DataType.Decimal
+            },
+            {
+                text: formatMessage({
+                    id: 'arduinoUnoOld.dataTypeMenu.string',
+                    default: 'string',
+                    description: 'label for string'
+                }),
+                value: DataType.String
+            }
+        ];
+    }
+
+    /**
+     * Construct a set of Arduino blocks.
+     * @param {Runtime} runtime - the OpenBlock runtime.
+     */
+    constructor (runtime) {
+        /**
+         * The OpenBlock runtime.
+         * @type {Runtime}
+         */
+        this.runtime = runtime;
+
+        // Create a new Arduino uno peripheral instance
+        this._peripheral = new ArduinoUno(this.runtime, OpenBlockArduinoUnoDevice.DEVICE_ID);
+    }
+
+    /**
+     * @returns {Array.<object>} metadata for this extension and its blocks.
+     */
+    getInfo () {
+        return [
+            {
+                id: 'pin',
+                name: formatMessage({
+                    id: 'arduinoUnoOld.category.pins',
+                    default: 'Pins',
+                    description: 'The name of the arduino uno device pin category'
+                }),
+                color1: '#4C97FF',
+                color2: '#3373CC',
+                color3: '#3373CC',
+
+                blocks: [
+                    {
+                        opcode: 'setPinMode',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.pins.setPinMode',
+                            default: 'set pin [PIN] mode [MODE]',
+                            description: 'arduinoUnoOld set pin mode'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'mode',
+                                defaultValue: Mode.Input
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'setDigitalOutput',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.pins.setDigitalOutput',
+                            default: 'set digital pin [PIN] out [LEVEL]',
+                            description: 'arduinoUnoOld set digital pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pins',
+                                defaultValue: Pins.D0
+                            },
+                            LEVEL: {
+                                type: ArgumentType.STRING,
+                                menu: 'level',
+                                defaultValue: Level.High
+                            }
+                        }
+                    },
+                    {
+
+                        opcode: 'setPwmOutput',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.pins.setPwmOutput',
+                            default: 'set pwm pin [PIN] out [OUT]',
+                            description: 'arduinoUnoOld set pwm pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+                        opcode: 'readDigitalPin',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.pins.readDigitalPin',
+                            default: 'read digital pin [PIN]',
+                            description: 'arduinoUnoOld read digital pin'
+                        }),
+                        blockType: BlockType.BOOLEAN,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'digitalPins',
+                                defaultValue: Pins.D0
+                            }
+                        }
+                    },
+                    {
+                        opcode: 'readAnalogPin',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.pins.readAnalogPin',
+                            default: 'read analog pin [PIN]',
+                            description: 'arduinoUnoOld read analog pin'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'analogPins',
+                                defaultValue: Pins.A0
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'setServoOutput',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.pins.setServoOutput',
+                            default: 'set servo pin [PIN] out [OUT]',
+                            description: 'arduinoUnoOld set servo pin out'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'pwmPins',
+                                defaultValue: Pins.D3
+                            },
+                            OUT: {
+                                type: ArgumentType.ANGLE,
+                                defaultValue: '0'
+                            }
+                        }
+                    },
+                    '---',
+                    {
+
+                        opcode: 'attachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.pins.attachInterrupt',
+                            default: 'attach interrupt pin [PIN] mode [MODE] executes',
+                            description: 'arduinoUnoOld attach interrupt'
+                        }),
+                        blockType: BlockType.CONDITIONAL,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            },
+                            MODE: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptMode',
+                                defaultValue: InterrupMode.Rising
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+
+                        opcode: 'detachInterrupt',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.pins.detachInterrupt',
+                            default: 'detach interrupt pin [PIN]',
+                            description: 'arduinoUnoOld detach interrupt'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            PIN: {
+                                type: ArgumentType.STRING,
+                                menu: 'interruptPins',
+                                defaultValue: Pins.D3
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    pins: {
+                        items: this.PINS_MENU
+                    },
+                    mode: {
+                        items: this.MODE_MENU
+                    },
+                    digitalPins: {
+                        items: this.DIGITAL_PINS_MENU
+                    },
+                    analogPins: {
+                        items: this.ANALOG_PINS_MENU
+                    },
+                    level: {
+                        acceptReporters: true,
+                        items: this.LEVEL_MENU
+                    },
+                    pwmPins: {
+                        items: this.PWM_PINS_MENU
+                    },
+                    interruptPins: {
+                        items: this.INTERRUPT_PINS_MENU
+                    },
+                    interruptMode: {
+                        items: this.INTERRUP_MODE_MENU
+                    }
+                }
+            },
+            {
+                id: 'serial',
+                name: formatMessage({
+                    id: 'arduinoUnoOld.category.serial',
+                    default: 'Serial',
+                    description: 'The name of the arduino uno device serial category'
+                }),
+                color1: '#9966FF',
+                color2: '#774DCB',
+                color3: '#774DCB',
+
+                blocks: [
+                    {
+                        opcode: 'serialBegin',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.serial.serialBegin',
+                            default: 'serial begin baudrate [VALUE]',
+                            description: 'arduinoUnoOld serial begin'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                menu: 'baudrate',
+                                defaultValue: Buadrate.B9600
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialPrint',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.serial.serialPrint',
+                            default: 'serial print [VALUE] [EOL]',
+                            description: 'arduinoUnoOld serial print'
+                        }),
+                        blockType: BlockType.COMMAND,
+                        arguments: {
+                            VALUE: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'hello'
+                            },
+                            EOL: {
+                                type: ArgumentType.STRING,
+                                menu: 'eol',
+                                defaultValue: Eol.Warp
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialAvailable',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.serial.serialAvailable',
+                            default: 'serial available data length',
+                            description: 'arduinoUnoOld serial available data length'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'serialReadData',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.serial.serialReadData',
+                            default: 'serial read data',
+                            description: 'arduinoUnoOld serial read data'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    baudrate: {
+                        items: this.BAUDTATE_MENU
+                    },
+                    eol: {
+                        items: this.EOL_MENU
+                    }
+                }
+            },
+            {
+                id: 'data',
+                name: formatMessage({
+                    id: 'arduinoUnoOld.category.data',
+                    default: 'Data',
+                    description: 'The name of the arduino uno device data category'
+                }),
+                color1: '#CF63CF',
+                color2: '#C94FC9',
+                color3: '#BD42BD',
+                blocks: [
+                    {
+                        opcode: 'dataMap',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.data.dataMap',
+                            default: 'map [DATA] from ([ARG0], [ARG1]) to ([ARG2], [ARG3])',
+                            description: 'arduinoUnoOld data map'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            },
+                            ARG2: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG3: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1000'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    '---',
+                    {
+                        opcode: 'dataConstrain',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.data.dataConstrain',
+                            default: 'constrain [DATA] between ([ARG0], [ARG1])',
+                            description: 'arduinoUnoOld data constrain'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '50'
+                            },
+                            ARG0: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '1'
+                            },
+                            ARG1: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '100'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvert',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.data.dataConvert',
+                            default: 'convert [DATA] to [TYPE]',
+                            description: 'arduinoUnoOld data convert'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: '123'
+                            },
+                            TYPE: {
+                                type: ArgumentType.STRING,
+                                menu: 'dataType',
+                                defaultValue: DataType.WholeNumber
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIICharacter',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.data.dataConvertASCIICharacter',
+                            default: 'convert [DATA] to ASCII character',
+                            description: 'arduinoUnoOld data convert to ASCII character'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.NUMBER,
+                                defaultValue: '97'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    },
+                    {
+                        opcode: 'dataConvertASCIINumber',
+                        text: formatMessage({
+                            id: 'arduinoUnoOld.data.dataConvertASCIINumber',
+                            default: 'convert [DATA] to ASCII nubmer',
+                            description: 'arduinoUnoOld data convert to ASCII nubmer'
+                        }),
+                        blockType: BlockType.REPORTER,
+                        arguments: {
+                            DATA: {
+                                type: ArgumentType.STRING,
+                                defaultValue: 'a'
+                            }
+                        },
+                        programMode: [ProgramModeType.UPLOAD]
+                    }
+                ],
+                menus: {
+                    dataType: {
+                        items: this.DATA_TYPE_MENU
+                    }
+                }
+            }
+        ];
+    }
+
+    /**
+     * Set pin mode.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin mode is done.
+     */
+    setPinMode (args) {
+        this._peripheral.setPinMode(args.PIN, args.MODE);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin digital out level.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin digital out level is done.
+     */
+    setDigitalOutput (args) {
+        this._peripheral.setDigitalOutput(args.PIN, args.LEVEL);
+        return Promise.resolve();
+    }
+
+    /**
+     * Set pin pwm out value.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set pin pwm out value is done.
+     */
+    setPwmOutput (args) {
+        this._peripheral.setPwmOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+
+    /**
+     * Read pin digital level.
+     * @param {object} args - the block's arguments.
+     * @return {boolean} - true if read high level, false if read low level.
+     */
+    readDigitalPin (args) {
+        return this._peripheral.readDigitalPin(args.PIN);
+    }
+
+    /**
+     * Read analog pin.
+     * @param {object} args - the block's arguments.
+     * @return {number} - analog value fo the pin.
+     */
+    readAnalogPin (args) {
+        return this._peripheral.readAnalogPin(args.PIN);
+    }
+
+    /**
+     * Set servo out put.
+     * @param {object} args - the block's arguments.
+     * @return {Promise} - a Promise that resolves after the set servo out value is done.
+     */
+    setServoOutput (args) {
+        this._peripheral.setServoOutput(args.PIN, args.OUT);
+        return Promise.resolve();
+    }
+}
+
+module.exports = OpenBlockArduinoUnoDevice;
diff --git a/node_modules/openblock-vm/src/extension-support/extension-manager.js b/node_modules/openblock-vm/src/extension-support/extension-manager.js
index bef87cf..d3c406b 100644
--- a/node_modules/openblock-vm/src/extension-support/extension-manager.js
+++ b/node_modules/openblock-vm/src/extension-support/extension-manager.js
@@ -31,7 +31,9 @@ const builtinExtensions = {
 
 const builtinDevices = {
     arduinoUno: () => require('../devices/arduinoUno'),
+    arduinoUnoOld: () => require('../devices/arduinoUnoOld'),
     arduinoNano: () => require('../devices/arduinoNano'),
+    arduinoNanoOld: () => require('../devices/arduinoNanoOld'),
     arduinoMini: () => require('../devices/arduinoMini'),
     arduinoLeonardo: () => require('../devices/arduinoLeonardo'),
     arduinoMega2560: () => require('../devices/arduinoMega2560'),
@@ -78,7 +80,7 @@ const builtinDevices = {
  */
 
 class ExtensionManager {
-    constructor (runtime) {
+    constructor(runtime) {
         /**
          * The ID number to provide to the next extension worker.
          * @type {int}
@@ -138,7 +140,7 @@ class ExtensionManager {
      * @param {string} extensionID - the ID of the extension.
      * @returns {boolean} - true if loaded, false otherwise.
      */
-    isExtensionLoaded (extensionID) {
+    isExtensionLoaded(extensionID) {
         return this._loadedExtensions.has(extensionID);
     }
 
@@ -149,7 +151,7 @@ class ExtensionManager {
      * @param {string} deviceID - the ID of the device.
      * @returns {boolean} - true if loaded, false otherwise.
      */
-    isDeviceLoaded (deviceID) {
+    isDeviceLoaded(deviceID) {
         return this._loadedDevice.has(deviceID);
     }
 
@@ -158,7 +160,7 @@ class ExtensionManager {
      * fail if the provided id is not does not match an internal extension.
      * @param {string} extensionId - the ID of an internal extension
      */
-    loadExtensionIdSync (extensionId) {
+    loadExtensionIdSync(extensionId) {
         if (!builtinExtensions.hasOwnProperty(extensionId)) {
             log.warn(`Could not find extension ${extensionId} in the built in extensions.`);
             return;
@@ -183,7 +185,7 @@ class ExtensionManager {
      * @param {string} extensionURL - the URL for the extension to load OR the ID of an internal extension
      * @returns {Promise} resolved once the extension is loaded and initialized or rejected on failure
      */
-    loadExtensionURL (extensionURL) {
+    loadExtensionURL(extensionURL) {
         if (builtinExtensions.hasOwnProperty(extensionURL)) {
             /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */
             if (this.isExtensionLoaded(extensionURL)) {
@@ -204,7 +206,7 @@ class ExtensionManager {
             // If we `require` this at the global level it breaks non-webpack targets, including tests
             const ExtensionWorker = require('worker-loader?name=extension-worker.js!./extension-worker');
 
-            this.pendingExtensions.push({extensionURL, resolve, reject});
+            this.pendingExtensions.push({ extensionURL, resolve, reject });
             dispatch.addWorker(new ExtensionWorker());
         });
     }
@@ -213,7 +215,7 @@ class ExtensionManager {
      * Get unbuild-in devices list from local server.
      * @returns {Promise} resolved devices list has been fetched or failure
      */
-    getDeviceList () {
+    getDeviceList() {
         return new Promise(resolve => {
             fetch(localDevicesUrl)
                 .then(response => response.json())
@@ -240,7 +242,7 @@ class ExtensionManager {
      * @param {Array.<string>} pnpidList - the array of pnpid list
      * @returns {Promise} resolved once the device is loaded and initialized or rejected on failure
      */
-    loadDeviceURL (deviceId, deviceType, pnpidList) {
+    loadDeviceURL(deviceId, deviceType, pnpidList) {
         const realDeviceId = this.runtime.analysisRealDeviceId(deviceId);
 
         if (builtinDevices.hasOwnProperty(realDeviceId)) {
@@ -275,7 +277,7 @@ class ExtensionManager {
      * Get device extensions list from local server.
      * @returns {Promise} resolved extension list has been fetched or failure
      */
-    getDeviceExtensionsList () {
+    getDeviceExtensionsList() {
         return new Promise(resolve => {
             fetch(localDeviceExtensionsUrl)
                 .then(response => response.json())
@@ -301,7 +303,7 @@ class ExtensionManager {
      * @param {string} deviceExtensionId - the ID of the device extension.
      * @returns {boolean} - true if loaded, false otherwise.
      */
-    isDeviceExtensionLoaded (deviceExtensionId) {
+    isDeviceExtensionLoaded(deviceExtensionId) {
         return this.runtime.isDeviceExtensionLoaded(deviceExtensionId);
     }
 
@@ -310,7 +312,7 @@ class ExtensionManager {
      * @param {string} deviceExtensionId - the ID of an device extension
      * @returns {Promise} resolved once the device extension is loaded or rejected on failure
      */
-    loadDeviceExtension (deviceExtensionId) {
+    loadDeviceExtension(deviceExtensionId) {
         // console.log('deviceExtensionId=', deviceExtensionId);
         return new Promise((resolve, reject) => {
             const deviceExtension = this._deviceExtensions.find(ext => ext.extensionId === deviceExtensionId);
@@ -325,12 +327,12 @@ class ExtensionManager {
             const generatorUrl = url + deviceExtension.generator;
             const msgUrl = url + deviceExtension.msg;
 
-            loadjs([toolboxUrl, blockUrl, generatorUrl, msgUrl], {returnPromise: true})
+            loadjs([toolboxUrl, blockUrl, generatorUrl, msgUrl], { returnPromise: true })
                 .then(() => {
                     const toolboxXML = addToolbox(); // eslint-disable-line no-undef
                     this.runtime.addDeviceExtension(deviceExtensionId, toolboxXML, deviceExtension.library);
 
-                    const addExts = {addBlocks, addGenerator, addMsg};// eslint-disable-line no-undef
+                    const addExts = { addBlocks, addGenerator, addMsg };// eslint-disable-line no-undef
 
                     this.runtime.emit(this.runtime.constructor.DEVICE_EXTENSION_ADDED, addExts);
                     return resolve();
@@ -345,7 +347,7 @@ class ExtensionManager {
      * @param {string} deviceExtensionId - the ID of an device extension
      * @returns {Promise} resolved once the device extension is unloaded or rejected on failure
      */
-    unloadDeviceExtension (deviceExtensionId) {
+    unloadDeviceExtension(deviceExtensionId) {
         return new Promise(resolve => {
             this.runtime.removeDeviceExtension(deviceExtensionId);
             this.runtime.emit(this.runtime.constructor.DEVICE_EXTENSION_REMOVED, deviceExtensionId);
@@ -357,7 +359,7 @@ class ExtensionManager {
      * Unload all device extensions
      * @returns {Promise} resolved once all device extensions is unloaded
      */
-    unloadAllDeviceExtension () {
+    unloadAllDeviceExtension() {
         const allPromises = [];
 
         const loadedDeviceExtensionId = this.runtime.getCurrentDeviceExtensionLoaded();
@@ -372,7 +374,7 @@ class ExtensionManager {
      * Regenerate blockinfo for any loaded extensions
      * @returns {Promise} resolved once all the extensions have been reinitialized
      */
-    refreshBlocks () {
+    refreshBlocks() {
         const allPromises = Array.from(this._loadedExtensions.values()).map(serviceName =>
             dispatch.call(serviceName, 'getInfo')
                 .then(info => {
@@ -396,7 +398,7 @@ class ExtensionManager {
         return Promise.all(allPromises);
     }
 
-    allocateWorker () {
+    allocateWorker() {
         const id = this.nextExtensionWorker++;
         const workerInfo = this.pendingExtensions.shift();
         this.pendingWorkers[id] = workerInfo;
@@ -407,7 +409,7 @@ class ExtensionManager {
      * Synchronously collect extension metadata from the specified service and begin the extension registration process.
      * @param {string} serviceName - the name of the service hosting the extension.
      */
-    registerExtensionServiceSync (serviceName) {
+    registerExtensionServiceSync(serviceName) {
         const info = dispatch.callSync(serviceName, 'getInfo');
         this._registerExtensionInfo(serviceName, info);
     }
@@ -416,7 +418,7 @@ class ExtensionManager {
      * Synchronously collect device metadata from the specified service and begin the device registration process.
      * @param {string} serviceName - the name of the service hosting the device.
      */
-    registerDeviceServiceSync (serviceName) {
+    registerDeviceServiceSync(serviceName) {
         const infos = dispatch.callSync(serviceName, 'getInfo');
         this._registerDeviceInfo(serviceName, infos);
     }
@@ -425,7 +427,7 @@ class ExtensionManager {
      * Collect extension metadata from the specified service and begin the extension registration process.
      * @param {string} serviceName - the name of the service hosting the extension.
      */
-    registerExtensionService (serviceName) {
+    registerExtensionService(serviceName) {
         dispatch.call(serviceName, 'getInfo').then(info => {
             this._registerExtensionInfo(serviceName, info);
         });
@@ -436,7 +438,7 @@ class ExtensionManager {
      * @param {int} id - the worker ID.
      * @param {*?} e - the error encountered during initialization, if any.
      */
-    onWorkerInit (id, e) {
+    onWorkerInit(id, e) {
         const workerInfo = this.pendingWorkers[id];
         delete this.pendingWorkers[id];
         if (e) {
@@ -451,7 +453,7 @@ class ExtensionManager {
      * @param {object} extensionObject - the extension object to register
      * @returns {string} The name of the registered extension service
      */
-    _registerInternalExtension (extensionObject) {
+    _registerInternalExtension(extensionObject) {
         const extensionInfo = extensionObject.getInfo();
         const fakeWorkerId = this.nextExtensionWorker++;
         const serviceName = `extension_${fakeWorkerId}_${extensionInfo.id}`;
@@ -465,7 +467,7 @@ class ExtensionManager {
      * @param {object} deviceObject - the device object to register
      * @returns {string} The name of the registered device service
      */
-    _registerInternalDevice (deviceObject) {
+    _registerInternalDevice(deviceObject) {
         const deviceId = deviceObject.DEVICE_ID;
         const fakeWorkerId = this.nextExtensionWorker++;
         const serviceName = `extension_${fakeWorkerId}_${deviceId}`;
@@ -480,7 +482,7 @@ class ExtensionManager {
      * @param {ExtensionInfo} extensionInfo - the extension's metadata
      * @private
      */
-    _registerExtensionInfo (serviceName, extensionInfo) {
+    _registerExtensionInfo(serviceName, extensionInfo) {
         extensionInfo = this._prepareExtensionInfo(serviceName, extensionInfo);
         dispatch.call('runtime', '_registerExtensionPrimitives', extensionInfo).catch(e => {
             log.error(`Failed to register primitives for extension on service ${serviceName}:`, e);
@@ -493,7 +495,7 @@ class ExtensionManager {
      * @param {Array.DeviceInfo} deviceInfos - the device's metadatas
      * @private
      */
-    _registerDeviceInfo (serviceName, deviceInfos) {
+    _registerDeviceInfo(serviceName, deviceInfos) {
         deviceInfos = this._prepareDeviceInfo(serviceName, deviceInfos);
         dispatch.call('runtime', '_registerDevicePrimitives', deviceInfos).catch(e => {
             log.error(`Failed to register primitives for device on service ${serviceName}:`, e);
@@ -506,7 +508,7 @@ class ExtensionManager {
      * @returns {string} - the sanitized text
      * @private
      */
-    _sanitizeID (text) {
+    _sanitizeID(text) {
         return text.toString().replace(/[<"&]/, '_');
     }
 
@@ -518,7 +520,7 @@ class ExtensionManager {
      * @returns {ExtensionInfo} - a new extension info object with cleaned-up values
      * @private
      */
-    _prepareExtensionInfo (serviceName, extensionInfo) {
+    _prepareExtensionInfo(serviceName, extensionInfo) {
         extensionInfo = Object.assign({}, extensionInfo);
         if (!/^[a-z0-9]+$/i.test(extensionInfo.id)) {
             throw new Error('Invalid extension id');
@@ -530,12 +532,12 @@ class ExtensionManager {
             try {
                 let result;
                 switch (blockInfo) {
-                case '---': // separator
-                    result = '---';
-                    break;
-                default: // an ExtensionBlockMetadata object
-                    result = this._prepareBlockInfo(serviceName, blockInfo);
-                    break;
+                    case '---': // separator
+                        result = '---';
+                        break;
+                    default: // an ExtensionBlockMetadata object
+                        result = this._prepareBlockInfo(serviceName, blockInfo);
+                        break;
                 }
                 results.push(result);
             } catch (e) {
@@ -556,7 +558,7 @@ class ExtensionManager {
      * @returns {Array.DeviceInfo} - a new device info object with cleaned-up values
      * @private
      */
-    _prepareDeviceInfo (serviceName, deviceInfos) {
+    _prepareDeviceInfo(serviceName, deviceInfos) {
         const infos = [];
         const deviceInfosCopy = JSON.parse(JSON.stringify(deviceInfos));
 
@@ -571,12 +573,12 @@ class ExtensionManager {
                 try {
                     let result;
                     switch (blockInfo) {
-                    case '---': // separator
-                        result = '---';
-                        break;
-                    default: // an ExtensionBlockMetadata object
-                        result = this._prepareBlockInfo(serviceName, blockInfo);
-                        break;
+                        case '---': // separator
+                            result = '---';
+                            break;
+                        default: // an ExtensionBlockMetadata object
+                            result = this._prepareBlockInfo(serviceName, blockInfo);
+                            break;
                     }
                     results.push(result);
                 } catch (e) {
@@ -598,7 +600,7 @@ class ExtensionManager {
      * @returns {Array.<MenuInfo>} - a menuInfo object with all preprocessing done.
      * @private
      */
-    _prepareMenuInfo (serviceName, menus) {
+    _prepareMenuInfo(serviceName, menus) {
         const menuNames = Object.getOwnPropertyNames(menus);
         for (let i = 0; i < menuNames.length; i++) {
             const menuName = menuNames[i];
@@ -631,7 +633,7 @@ class ExtensionManager {
      * @returns {Array} menu items ready for scratch-blocks.
      * @private
      */
-    _getExtensionMenuItems (extensionObject, menuItemFunctionName) {
+    _getExtensionMenuItems(extensionObject, menuItemFunctionName) {
         // Fetch the items appropriate for the target currently being edited. This assumes that menus only
         // collect items when opened by the user while editing a particular target.
         const editingTarget = this.runtime.getEditingTarget() || this.runtime.getTargetForStage();
@@ -644,15 +646,15 @@ class ExtensionManager {
             item => {
                 item = maybeFormatMessage(item, extensionMessageContext);
                 switch (typeof item) {
-                case 'object':
-                    return [
-                        maybeFormatMessage(item.text, extensionMessageContext),
-                        item.value
-                    ];
-                case 'string':
-                    return [item, item];
-                default:
-                    return item;
+                    case 'object':
+                        return [
+                            maybeFormatMessage(item.text, extensionMessageContext),
+                            item.value
+                        ];
+                    case 'string':
+                        return [item, item];
+                    default:
+                        return item;
                 }
             });
 
@@ -669,7 +671,7 @@ class ExtensionManager {
      * @returns {ExtensionBlockMetadata} - a new block info object which has values for all relevant optional fields.
      * @private
      */
-    _prepareBlockInfo (serviceName, blockInfo) {
+    _prepareBlockInfo(serviceName, blockInfo) {
         blockInfo = Object.assign({}, {
             blockType: BlockType.COMMAND,
             terminal: false,
@@ -680,50 +682,50 @@ class ExtensionManager {
         blockInfo.text = blockInfo.text || blockInfo.opcode;
 
         switch (blockInfo.blockType) {
-        case BlockType.EVENT:
-            if (blockInfo.func) {
-                log.warn(`Ignoring function "${blockInfo.func}" for event block ${blockInfo.opcode}`);
-            }
-            break;
-        case BlockType.BUTTON:
-            if (blockInfo.opcode) {
-                log.warn(`Ignoring opcode "${blockInfo.opcode}" for button with text: ${blockInfo.text}`);
-            }
-            break;
-        default: {
-            if (!blockInfo.opcode) {
-                throw new Error('Missing opcode for block');
-            }
+            case BlockType.EVENT:
+                if (blockInfo.func) {
+                    log.warn(`Ignoring function "${blockInfo.func}" for event block ${blockInfo.opcode}`);
+                }
+                break;
+            case BlockType.BUTTON:
+                if (blockInfo.opcode) {
+                    log.warn(`Ignoring opcode "${blockInfo.opcode}" for button with text: ${blockInfo.text}`);
+                }
+                break;
+            default: {
+                if (!blockInfo.opcode) {
+                    throw new Error('Missing opcode for block');
+                }
 
-            const funcName = blockInfo.func ? this._sanitizeID(blockInfo.func) : blockInfo.opcode;
+                const funcName = blockInfo.func ? this._sanitizeID(blockInfo.func) : blockInfo.opcode;
 
-            const getBlockInfo = blockInfo.isDynamic ?
-                args => args && args.mutation && args.mutation.blockInfo :
-                () => blockInfo;
-            const callBlockFunc = (() => {
-                if (dispatch._isRemoteService(serviceName)) {
+                const getBlockInfo = blockInfo.isDynamic ?
+                    args => args && args.mutation && args.mutation.blockInfo :
+                    () => blockInfo;
+                const callBlockFunc = (() => {
+                    if (dispatch._isRemoteService(serviceName)) {
+                        return (args, util, realBlockInfo) =>
+                            dispatch.call(serviceName, funcName, args, util, realBlockInfo);
+                    }
+
+                    // avoid promise latency if we can call direct
+                    const serviceObject = dispatch.services[serviceName];
+                    if (!serviceObject[funcName]) {
+                        // The function might show up later as a dynamic property of the service object
+                        log.warn(`Could not find extension block function called ${funcName}`);
+                        return () => { };
+                    }
                     return (args, util, realBlockInfo) =>
-                        dispatch.call(serviceName, funcName, args, util, realBlockInfo);
-                }
+                        serviceObject[funcName](args, util, realBlockInfo);
+                })();
 
-                // avoid promise latency if we can call direct
-                const serviceObject = dispatch.services[serviceName];
-                if (!serviceObject[funcName]) {
-                    // The function might show up later as a dynamic property of the service object
-                    log.warn(`Could not find extension block function called ${funcName}`);
-                    return () => { };
-                }
-                return (args, util, realBlockInfo) =>
-                    serviceObject[funcName](args, util, realBlockInfo);
-            })();
-
-            blockInfo.func = (args, util) => {
-                const realBlockInfo = getBlockInfo(args);
-                // TODO: filter args using the keys of realBlockInfo.arguments? maybe only if sandboxed?
-                return callBlockFunc(args, util, realBlockInfo);
-            };
-            break;
-        }
+                blockInfo.func = (args, util) => {
+                    const realBlockInfo = getBlockInfo(args);
+                    // TODO: filter args using the keys of realBlockInfo.arguments? maybe only if sandboxed?
+                    return callBlockFunc(args, util, realBlockInfo);
+                };
+                break;
+            }
         }
 
         return blockInfo;
diff --git a/node_modules/openblock-vm/src/extension-support/extension-manager.zip b/node_modules/openblock-vm/src/extension-support/extension-manager.zip
new file mode 100644
index 0000000..a22572b
Binary files /dev/null and b/node_modules/openblock-vm/src/extension-support/extension-manager.zip differ
